<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一名行进中的码农</title>
  <icon>https://www.gravatar.com/avatar/6f2743e2a98d39f593e82cd0cc9c16b7</icon>
  <subtitle>热爱互联网，好好搬砖</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-07T16:41:55.877Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>俊雪恋</name>
    <email>917136891@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20届找实习之阿里，头条，网易，小米，搜狐，百度等面经合集</title>
    <link href="http://yoursite.com/2018/03/08/20%E5%B1%8A%E6%89%BE%E5%AE%9E%E4%B9%A0%E4%B9%8B%E9%98%BF%E9%87%8C%EF%BC%8C%E5%A4%B4%E6%9D%A1%EF%BC%8C%E7%BD%91%E6%98%93%EF%BC%8C%E5%B0%8F%E7%B1%B3%EF%BC%8C%E6%90%9C%E7%8B%90%EF%BC%8C%E7%99%BE%E5%BA%A6%E7%AD%89%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2018/03/08/20届找实习之阿里，头条，网易，小米，搜狐，百度等面经合集/</id>
    <published>2018-03-07T16:28:34.000Z</published>
    <updated>2018-03-07T16:41:55.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="头条一二面（挂）"><a href="#头条一二面（挂）" class="headerlink" title="头条一二面（挂）"></a>头条一二面（挂）</h2><p>头条1面：<br>自我介绍<br>项目介绍<br>平时使用开的环境<br>redis获取一个hash的长度<br>用redis做过控频吗<br>能接受转语言吗<br>http状态码301,302<br>手写快排<br>头条2面：<br>网络部分：<br>DHCP如何实现分配ip的<br>ISO七层模型，每层都说下自己的理解和知道的，说的越多越好<br>TCP和UDP的区别，TCP如何保证可靠传输的<br>说一下常使用的协议及其对应的端口<br>Linux部分：<br>I/O多路复用<br>进程间如何通信<br>动态链接和静态链接的区别<br>进程的内存分布<br>如何查找一个进程打开所有的文件<br>设计模式：<br>工厂设计模式<br>单例设计模式<br>讲一下，说一下应用的场景。</p><h2 id="网易两面（意思给过）"><a href="#网易两面（意思给过）" class="headerlink" title="网易两面（意思给过）"></a>网易两面（意思给过）</h2><p>自我介绍<br>hashmap<br>怎么优化这段代码<br><img src="/2018/03/08/20届找实习之阿里，头条，网易，小米，搜狐，百度等面经合集/优化代码.png" alt="优化代码"><br>两道简单算法<br>1、求连续子数组的最大和问题<br>2、走格子，从一个出发点到终点，只能向上和向右有多少种走法，连障碍点都没有<br>Java如何进行垃圾回收的<br>你用过哪些设计模式？回答：单例，观察者，工厂，责任链，适配器<br>JDK中哪些实现了单例模式？java.lang.reflect.Proxy类，java.lang.Runtime类，线程池。<br>两道设计题<br>第一道设计题：<br>比如我有个电商平台，做每日订单的异常检测，服务端代码应该写。、<br>第二道设计题：<br>比如窝网易邮箱春节要做一个活动，我网易邮箱用户量有3.4亿吧！但是我只允许8千万人参加，最后在8千万人里面产生一二三等奖，有一台物理机和一台数据库服务器。你怎么来设计。</p><p>二面<br>为什么会有内核态，保护模式你知道吗?<br>文件是怎么在磁盘上存储的？<br>有了进程为何还要线程呢，不同进程和线程他们之间有什么不同<br>dhcp数据包格式及其原理<br>innodb聚集索引b+树叶子节点和磁盘什么顺序相同。</p><h2 id="阿里一面"><a href="#阿里一面" class="headerlink" title="阿里一面"></a>阿里一面</h2><p>1、自我介绍<br>2、全程怼项目，问的及其细，包括你为什么选择这种方案来实现，<br>具体怎么存储怎么做的，相当细，遇到这类面试官，项目不够熟，就会翻车了。<br>3、redis原子操作怎么y用比较好<br>4、消息队列会吗？<br><a id="more"></a></p><h2 id="小米明天2点面，占坑"><a href="#小米明天2点面，占坑" class="headerlink" title="小米明天2点面，占坑"></a>小米明天2点面，占坑</h2><h2 id="搜狐周六面-占坑"><a href="#搜狐周六面-占坑" class="headerlink" title="搜狐周六面 占坑"></a>搜狐周六面 占坑</h2><h2 id="百度测开，等预约面试时间"><a href="#百度测开，等预约面试时间" class="headerlink" title="百度测开，等预约面试时间"></a>百度测开，等预约面试时间</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;头条一二面（挂）&quot;&gt;&lt;a href=&quot;#头条一二面（挂）&quot; class=&quot;headerlink&quot; title=&quot;头条一二面（挂）&quot;&gt;&lt;/a&gt;头条一二面（挂）&lt;/h2&gt;&lt;p&gt;头条1面：&lt;br&gt;自我介绍&lt;br&gt;项目介绍&lt;br&gt;平时使用开的环境&lt;br&gt;redis获取一个hash的长度&lt;br&gt;用redis做过控频吗&lt;br&gt;能接受转语言吗&lt;br&gt;http状态码301,302&lt;br&gt;手写快排&lt;br&gt;头条2面：&lt;br&gt;网络部分：&lt;br&gt;DHCP如何实现分配ip的&lt;br&gt;ISO七层模型，每层都说下自己的理解和知道的，说的越多越好&lt;br&gt;TCP和UDP的区别，TCP如何保证可靠传输的&lt;br&gt;说一下常使用的协议及其对应的端口&lt;br&gt;Linux部分：&lt;br&gt;I/O多路复用&lt;br&gt;进程间如何通信&lt;br&gt;动态链接和静态链接的区别&lt;br&gt;进程的内存分布&lt;br&gt;如何查找一个进程打开所有的文件&lt;br&gt;设计模式：&lt;br&gt;工厂设计模式&lt;br&gt;单例设计模式&lt;br&gt;讲一下，说一下应用的场景。&lt;/p&gt;
&lt;h2 id=&quot;网易两面（意思给过）&quot;&gt;&lt;a href=&quot;#网易两面（意思给过）&quot; class=&quot;headerlink&quot; title=&quot;网易两面（意思给过）&quot;&gt;&lt;/a&gt;网易两面（意思给过）&lt;/h2&gt;&lt;p&gt;自我介绍&lt;br&gt;hashmap&lt;br&gt;怎么优化这段代码&lt;br&gt;&lt;img src=&quot;/2018/03/08/20届找实习之阿里，头条，网易，小米，搜狐，百度等面经合集/优化代码.png&quot; alt=&quot;优化代码&quot;&gt;&lt;br&gt;两道简单算法&lt;br&gt;1、求连续子数组的最大和问题&lt;br&gt;2、走格子，从一个出发点到终点，只能向上和向右有多少种走法，连障碍点都没有&lt;br&gt;Java如何进行垃圾回收的&lt;br&gt;你用过哪些设计模式？回答：单例，观察者，工厂，责任链，适配器&lt;br&gt;JDK中哪些实现了单例模式？java.lang.reflect.Proxy类，java.lang.Runtime类，线程池。&lt;br&gt;两道设计题&lt;br&gt;第一道设计题：&lt;br&gt;比如我有个电商平台，做每日订单的异常检测，服务端代码应该写。、&lt;br&gt;第二道设计题：&lt;br&gt;比如窝网易邮箱春节要做一个活动，我网易邮箱用户量有3.4亿吧！但是我只允许8千万人参加，最后在8千万人里面产生一二三等奖，有一台物理机和一台数据库服务器。你怎么来设计。&lt;/p&gt;
&lt;p&gt;二面&lt;br&gt;为什么会有内核态，保护模式你知道吗?&lt;br&gt;文件是怎么在磁盘上存储的？&lt;br&gt;有了进程为何还要线程呢，不同进程和线程他们之间有什么不同&lt;br&gt;dhcp数据包格式及其原理&lt;br&gt;innodb聚集索引b+树叶子节点和磁盘什么顺序相同。&lt;/p&gt;
&lt;h2 id=&quot;阿里一面&quot;&gt;&lt;a href=&quot;#阿里一面&quot; class=&quot;headerlink&quot; title=&quot;阿里一面&quot;&gt;&lt;/a&gt;阿里一面&lt;/h2&gt;&lt;p&gt;1、自我介绍&lt;br&gt;2、全程怼项目，问的及其细，包括你为什么选择这种方案来实现，&lt;br&gt;具体怎么存储怎么做的，相当细，遇到这类面试官，项目不够熟，就会翻车了。&lt;br&gt;3、redis原子操作怎么y用比较好&lt;br&gt;4、消息队列会吗？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面经" scheme="http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>19届实习前端面经</title>
    <link href="http://yoursite.com/2018/01/10/19%E5%B1%8A%E5%AE%9E%E4%B9%A0%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    <id>http://yoursite.com/2018/01/10/19届实习前端面经/</id>
    <published>2018-01-10T02:33:34.000Z</published>
    <updated>2018-01-10T03:05:50.194Z</updated>
    
    <content type="html"><![CDATA[<p>本人是Java后台，所以不能很好地整理学弟前端的实习面经，你们凑合着看吧!学弟很巅峰除了上述提到了，头条，腾讯实习offer均拿到了。</p><h2 id="网易考拉"><a href="#网易考拉" class="headerlink" title="网易考拉"></a>网易考拉</h2><p>跨域<br>promise<br>es6<br>flex<br>generator<br><a id="more"></a></p><p>项目有关<br>Echarts最难的一个点<br>雪碧图怎么做</p><h2 id="360"><a href="#360" class="headerlink" title="360"></a>360</h2><p>前后端合作<br>文档书写<br>webpack<br>Vue原理<br>diff原理<br>ES6<br>微信换Token流程<br>微信为什么限制接口申请频率<br>XSS<br>CSRF<br>CSS模块化<br>动画优化</p><p>二面<br>你对Vue有什么看法<br>网络错误如何debug</p><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><p>一面</p><p>HTML5新增特性<br>CSS3垂直居中<br>ES6特性<br>Event Loop<br>axios 发送 formData：<br>HTML5 储存<br>web Worker<br>webSocket<br>Promise<br>MongoDB<br>canvas<br>this指向<br>箭头函数<br>new 发生了什么<br>在构造函数中显示 return<br>前端优化<br>Vue 组件通信 / props 单向数据流<br>Nuxt原理<br>Git如何解决冲突</p><p>二面<br>Promise及其循环调用、顺序调用、无限调用<br>Promise如何取消<br>Promise 有没有不论成功失败都会执行的<br>ES6新数据结构<br>Map和Object区别<br>迭代器<br>迭代协议<br>可迭代对象<br>vue实现树组件<br>读过vue源码吗<br>vue-router 原理<br>express<br>Mongo<br>Mongo如何搭建集群<br>Node如何搭建集群</p><h2 id="滴滴-大数据平台"><a href="#滴滴-大数据平台" class="headerlink" title="滴滴-大数据平台"></a>滴滴-大数据平台</h2><p>在大型项目中有遇见什么问题吗<br>对组件化有什么看法<br>推荐用vue还是react，为什么<br>组件化粒度</p><h2 id="思宇信息"><a href="#思宇信息" class="headerlink" title="思宇信息"></a>思宇信息</h2><p>一面<br>px、em、rem<br>优化<br>jsonp<br>this<br>call、apply<br>json 可以用来干啥<br>HTML5<br>position<br>css选择器</p><h2 id="百度-大搜"><a href="#百度-大搜" class="headerlink" title="百度-大搜"></a>百度-大搜</h2><p>垂直居中<br>rem<br>gird<br>盒模型<br>闭包<br>事件模型<br>跨域<br>diff<br>截图库内部原理，html2canvas具体过程<br>SSR性能问题有哪些，怎么解决<br>图的基本算法<br>数据库性能<br>高QPS系统如何个设计<br>内存数据库和持久化数据库架构设计<br>整个HTTP请求过程。HTTP内容有哪些<br>vdom的diff<br>Vue模板编译，和其他模板系统有什么区别</p><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>一面<br>盒模型<br>BFC<br>数组的所有方法<br>this<br>事件机制<br>setTimeout<br>HTTP code<br>缓存<br>AMD、CMD<br>Vue的理解<br>diff<br>私有变量如何实现<br>原型链、继承</p><h2 id="百度-1"><a href="#百度-1" class="headerlink" title="百度"></a>百度</h2><p> 一面<br>网络：五层模型、三次握手、四次挥手、HTTP、HTTPS<br>数据结构：完全二叉树<br>操作系统：线程、进程<br>CSS 会不会阻塞（不阻塞解析阻塞渲染）<br>闪烁问题<br>页面渲染机制<br>项目</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人是Java后台，所以不能很好地整理学弟前端的实习面经，你们凑合着看吧!学弟很巅峰除了上述提到了，头条，腾讯实习offer均拿到了。&lt;/p&gt;
&lt;h2 id=&quot;网易考拉&quot;&gt;&lt;a href=&quot;#网易考拉&quot; class=&quot;headerlink&quot; title=&quot;网易考拉&quot;&gt;&lt;/a&gt;网易考拉&lt;/h2&gt;&lt;p&gt;跨域&lt;br&gt;promise&lt;br&gt;es6&lt;br&gt;flex&lt;br&gt;generator&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL执行计划解读</title>
    <link href="http://yoursite.com/2018/01/09/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/01/09/MySQL执行计划解读/</id>
    <published>2018-01-09T08:12:54.000Z</published>
    <updated>2018-01-09T13:43:07.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL执行计划能告诉我们什么？"><a href="#MySQL执行计划能告诉我们什么？" class="headerlink" title="MySQL执行计划能告诉我们什么？"></a>MySQL执行计划能告诉我们什么？</h2><p>MySQL优化器是如何处理我们所提交的SQl请求的。SQL如何使用索引的。联接查询的执行顺序。查询扫描的数据行数。无法展示存储过程，触发器，UDF对查询的影响。</p><h2 id="如何查看MySQL的执行计划"><a href="#如何查看MySQL的执行计划" class="headerlink" title="如何查看MySQL的执行计划"></a>如何查看MySQL的执行计划</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">SELECT c.`category_name`,a.`product_name`,b.`title`</span><br><span class="line">FROM product_info a</span><br><span class="line">JOIN product_comment b ON a.`product_id`=b.`product_id`</span><br><span class="line">JOIN product_category c ON c.`category_id`=a.`one_category_id`;</span><br></pre></td></tr></table></figure><p>加上EXPLAIN关键字就可以了。接下来解释每一列所代表的含义。<a id="more"></a><br><img src="/2018/01/09/MySQL执行计划解读/执行计划结果.png" alt="执行计划结果"></p><h2 id="解读MySQL执行计划"><a href="#解读MySQL执行计划" class="headerlink" title="解读MySQL执行计划"></a>解读MySQL执行计划</h2><p>ID列:ID列中的数据为一组数字，表示执行select语句的顺序。ID值相同时，执行顺序由上至下。ID值越大优先级越高，越先被执行。<br>select_type列：<br><img src="/2018/01/09/MySQL执行计划解读/select_type列解读.png" alt="select_type列解读"><br>table列：输出数据行所在表的名称。(unionM,N)由ID为M，N查询union产生的结果集。(derivedN/subqueryN)由ID为N的查询产生的结果。<br>partitions列:对于分区表，显示查询的分区ID。对于非分区表，显示为NULL。<br>type列:<br><img src="/2018/01/09/MySQL执行计划解读/type列解读.jpg" alt="type列解读"><br>extra列:<br><img src="/2018/01/09/MySQL执行计划解读/extra列解读.png" alt="extra列解读"><br>possible_keys列:显示出MySQL能使用哪些索引来优化查询。查询列所涉及到的列上的索引都会被列出，但不一定会被使用。<br>key列:查询优化器优化查询实际所使用的索引。如果没有可用的索引，则显示为NULL。如查询使用了覆盖索引，则该索引仅出现在key列中。<br>key_len列:表示索引字段的最大可能长度。<br>ref列:表示那些列或常量被用于查找索引列上的值。<br>rows列:表示MySQl通过索引统计信息，估算的所需读取的行数，并不准确。<br>filtered列:表示返回结果的行数占需读取行数的百分比，值越大越好，并不准确。<br>做个小笔记:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT customer_id,title,content</span><br><span class="line">FROM `product_comment`</span><br><span class="line">WHERE audit_status = 1</span><br><span class="line">AND product_id = 199726</span><br><span class="line">LIMIT 0,15;</span><br></pre></td></tr></table></figure></p><p>优化如下语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT t.customer_id,t.title,t.content</span><br><span class="line">FROM ( </span><br><span class="line">SELECT comment_id</span><br><span class="line">FROM product_comment</span><br><span class="line">WHERE product_id = 199727 AND audit_status=1 LIMIT 0, 15</span><br><span class="line">) a JOIN product_comment t</span><br><span class="line">ON a.comment_id = t.comment_id;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL执行计划能告诉我们什么？&quot;&gt;&lt;a href=&quot;#MySQL执行计划能告诉我们什么？&quot; class=&quot;headerlink&quot; title=&quot;MySQL执行计划能告诉我们什么？&quot;&gt;&lt;/a&gt;MySQL执行计划能告诉我们什么？&lt;/h2&gt;&lt;p&gt;MySQL优化器是如何处理我们所提交的SQl请求的。SQL如何使用索引的。联接查询的执行顺序。查询扫描的数据行数。无法展示存储过程，触发器，UDF对查询的影响。&lt;/p&gt;
&lt;h2 id=&quot;如何查看MySQL的执行计划&quot;&gt;&lt;a href=&quot;#如何查看MySQL的执行计划&quot; class=&quot;headerlink&quot; title=&quot;如何查看MySQL的执行计划&quot;&gt;&lt;/a&gt;如何查看MySQL的执行计划&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;EXPLAIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SELECT c.`category_name`,a.`product_name`,b.`title`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FROM product_info a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JOIN product_comment b ON a.`product_id`=b.`product_id`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JOIN product_category c ON c.`category_id`=a.`one_category_id`;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;加上EXPLAIN关键字就可以了。接下来解释每一列所代表的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL执行计划解读" scheme="http://yoursite.com/tags/MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql设计规范</title>
    <link href="http://yoursite.com/2018/01/07/Mysql%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/01/07/Mysql设计规范/</id>
    <published>2018-01-07T13:06:36.000Z</published>
    <updated>2018-01-08T04:31:23.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql数据库设计规范"><a href="#Mysql数据库设计规范" class="headerlink" title="Mysql数据库设计规范"></a>Mysql数据库设计规范</h1><p>1、数据库命名规范<br>2、数据库基本设计规范<br>3、数据库索引设计规范<br>4、数据库字段设计规范<br>5、数据库SQL开发规范<br>6、数据库操作行为规范（针对运维）<br><a id="more"></a></p><h2 id="1-数据库命名规范"><a href="#1-数据库命名规范" class="headerlink" title="1.数据库命名规范"></a>1.数据库命名规范</h2><h3 id="1-所有数据库对象名称必须使用小写字母并用下划线分割"><a href="#1-所有数据库对象名称必须使用小写字母并用下划线分割" class="headerlink" title="1.所有数据库对象名称必须使用小写字母并用下划线分割"></a>1.所有数据库对象名称必须使用小写字母并用下划线分割</h3><p>因为在Linux系统下，Mysql数据库对象名称默认情况下大小写敏感。大小混用，会为以后开发带来不必要的麻烦。我们统一规范，为后面开发带来便利。<br>例如，不同的数据库名： DbName dbname 不同表名： Table table tabLe</p><h3 id="2-所有数据库对象名称禁止使用Mysql保留关键字"><a href="#2-所有数据库对象名称禁止使用Mysql保留关键字" class="headerlink" title="2.所有数据库对象名称禁止使用Mysql保留关键字"></a>2.所有数据库对象名称禁止使用Mysql保留关键字</h3><p>例如，用户表中会有一个字段from记录用户来源。select id,username,<code>from</code>,age from td_user;以下网址可查询Mysql关键字<a href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html。" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/keywords.html。</a></p><h3 id="3-数据库对象命名要能做到见名知义，并且最好不要超过32个字符。"><a href="#3-数据库对象命名要能做到见名知义，并且最好不要超过32个字符。" class="headerlink" title="3.数据库对象命名要能做到见名知义，并且最好不要超过32个字符。"></a>3.数据库对象命名要能做到见名知义，并且最好不要超过32个字符。</h3><p>需要注意的是32个字符不是Mysql的限制。例如 用户数据库ds_userdb,用户账号表 user_account。<br>针对临时库、表必须以tmp为前缀并以日期为后缀。备份库，备份表必须以bak为前缀并以日期为后缀。<br>所有存储相同数据的列名和列类型必须一致。避免关联查询时，如果两个表关联列数据类型不同的话，会进行隐式的数据类型转换，会造成列上的索引失效，会让查询效率降低。</p><h2 id="2-数据库基本设计规范"><a href="#2-数据库基本设计规范" class="headerlink" title="2.数据库基本设计规范"></a>2.数据库基本设计规范</h2><h3 id="1-使用Innodb作为默认存储引擎"><a href="#1-使用Innodb作为默认存储引擎" class="headerlink" title="1.使用Innodb作为默认存储引擎"></a>1.使用Innodb作为默认存储引擎</h3><p>mysql5.5之前Myisam是默认存储引擎。顺便对比下Innodb和Myisam两种存储引擎。Innodb是聚集索引，支持事务，支持行级锁（S锁，X锁）。Myisam是非聚集索引，不支持事务，只支持表锁。</p><h3 id="2-数据库和表的字符集统一使用UTF8"><a href="#2-数据库和表的字符集统一使用UTF8" class="headerlink" title="2.数据库和表的字符集统一使用UTF8"></a>2.数据库和表的字符集统一使用UTF8</h3><p>选择UTF8字符集是它兼容性更好，包括了我们所使用的基本字符，如有表情，那就使用UTF8的扩展字符集。 </p><h3 id="3-所有表和字段都需要添加注释"><a href="#3-所有表和字段都需要添加注释" class="headerlink" title="3.所有表和字段都需要添加注释"></a>3.所有表和字段都需要添加注释</h3><p>建表语句上使用comment从句添加表和列的备注。从一开始就进行数据字典的维护。而不得不去读代码去猜测数据表。</p><h3 id="4-控制单表数据量的大小，建议控制在500万以内"><a href="#4-控制单表数据量的大小，建议控制在500万以内" class="headerlink" title="4.控制单表数据量的大小，建议控制在500万以内"></a>4.控制单表数据量的大小，建议控制在500万以内</h3><p>需要注意是500万并不是Mysql数据库的限制，数据量太大修改表结构，备份，恢复都会有很大问题。这种限制取决于存储设置和文件系统。需要使用分库分表等手段来控制数据量大小。</p><h3 id="5-谨慎使用Mysql分区表"><a href="#5-谨慎使用Mysql分区表" class="headerlink" title="5.谨慎使用Mysql分区表"></a>5.谨慎使用Mysql分区表</h3><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表。分区表在不同的磁盘阵列上，才会对IO有优化作用。谨慎选择分区键，跨分区查询效率可能更低。比如订单表，用订单号作为分区键，如果查询某个用户所有订单，一定要跨分区查找，这样的查询效率可能更低。建议采用物理分表的方式管理大数据。</p><h3 id="6-尽量做到冷热数据分离，减少表的宽度"><a href="#6-尽量做到冷热数据分离，减少表的宽度" class="headerlink" title="6.尽量做到冷热数据分离，减少表的宽度"></a>6.尽量做到冷热数据分离，减少表的宽度</h3><p>mysql限制最多存储4096列。一行数据不超过65536字节。为了减少IO，保证热数据的内存缓存命中率。更有效的利用缓存，避免读入无用的冷数据。垂直拆分的建议是经常使用的列放在一个表中。</p><h3 id="7-禁止在表中建立预留字段"><a href="#7-禁止在表中建立预留字段" class="headerlink" title="7.禁止在表中建立预留字段"></a>7.禁止在表中建立预留字段</h3><p>违反1.3条。修改表数据类型，会对表进行锁定，比增加字段，更耗性能。</p><h3 id="8-其他规则"><a href="#8-其他规则" class="headerlink" title="8.其他规则"></a>8.其他规则</h3><p>禁止在数据库中存储图片，文件等二进制数据。<br>禁止在线上做数据库压力测试。<br>禁止从开发环境，测试环境直连生产环境数据库。</p><h2 id="3-索引设计规范"><a href="#3-索引设计规范" class="headerlink" title="3.索引设计规范"></a>3.索引设计规范</h2><p>索引对数据库的查询性能来说是相当重要的。不要滥用索引，单张表索引不超过5个。索引并不是越多越好，索引可以提高效率同样可以降低效率。索引可以增加查询效率，但同样也会降低插入和更新的效率。同时索引过多，Mysql优化器进行查询计划选择时也会更慢。<br>常见索引列建议：<br>select、update、delete语句的where从句的列<br>包含在order by、group by、distinct中的字段<br>多表jion的关联列<br>索引是最左匹配原则，区分度最高的列放在联合索引的最左侧。尽量把字段长度小的列放在联合索引的最左侧。使用最频繁的列放在联合索引的最左侧。<br>对于频繁的查询优先考虑使用覆盖索引，覆盖索引：就是包含了所有查询字段的索引。避免Innodb表进行索引的二次查找。可以把随机IO变为顺序IO加快查询效率。<br>尽量避免使用外键。不建议使用外键约束，但一定在表与表之间的关联键上建立索引。外键会影响父表和子表的写操作从而降性能。</p><h2 id="4-数据库字段设计规范"><a href="#4-数据库字段设计规范" class="headerlink" title="4.数据库字段设计规范"></a>4.数据库字段设计规范</h2><p>字段类型的选择，会直接影响数据库的性能。</p><h3 id="1-优先选择符合存储需要的最小的数据类型"><a href="#1-优先选择符合存储需要的最小的数据类型" class="headerlink" title="1.优先选择符合存储需要的最小的数据类型"></a>1.优先选择符合存储需要的最小的数据类型</h3><p>其实难以确定。将字符串转化为数字类型存储，Mysql提供函数，INET_ATON(‘255.255.255.255’) = 4294967295 INET_ATON(‘4294967295 ‘) = 4294967295。对于非负数据采用无符号整型进行存储。signed int -2147483648~2147483647 unsigned int 0~4294967295。varchar(N)中N代表的是字符数，，而不是字节数。<br>使用UTF8存储汉字Varchar(255) = 765个字节。避免使用Text、Blob数据类型。</p><h3 id="2-尽可能把所有列定义为NOT-NULL"><a href="#2-尽可能把所有列定义为NOT-NULL" class="headerlink" title="2.尽可能把所有列定义为NOT NULL"></a>2.尽可能把所有列定义为NOT NULL</h3><p>索引NULL列需要额外的空间来保存，所以要占用更多的空间<br>进行比较和计算时要对NULL值做特别的处理</p><h3 id="3-使用TimeStamp或DateTime类型来存储时间"><a href="#3-使用TimeStamp或DateTime类型来存储时间" class="headerlink" title="3.使用TimeStamp或DateTime类型来存储时间"></a>3.使用TimeStamp或DateTime类型来存储时间</h3><h3 id="4-财务相关的金额类数据，必须使用decimal类型"><a href="#4-财务相关的金额类数据，必须使用decimal类型" class="headerlink" title="4.财务相关的金额类数据，必须使用decimal类型"></a>4.财务相关的金额类数据，必须使用decimal类型</h3><h2 id="5、数据库SQL开发规范"><a href="#5、数据库SQL开发规范" class="headerlink" title="5、数据库SQL开发规范"></a>5、数据库SQL开发规范</h2><h3 id="1-建议使用预编译语句进行数据库操作"><a href="#1-建议使用预编译语句进行数据库操作" class="headerlink" title="1.建议使用预编译语句进行数据库操作"></a>1.建议使用预编译语句进行数据库操作</h3><p>只传参数，比传递sql语句更高效。避免sql注入。</p><h3 id="2-避免数据类型的隐式转换"><a href="#2-避免数据类型的隐式转换" class="headerlink" title="2.避免数据类型的隐式转换"></a>2.避免数据类型的隐式转换</h3><p>隐式转换会导致索引失效。</p><h3 id="3-充分利用表上已经存在的索引"><a href="#3-充分利用表上已经存在的索引" class="headerlink" title="3.充分利用表上已经存在的索引"></a>3.充分利用表上已经存在的索引</h3><p>避免使用双%号的查询条件。如a like ‘%123%’(后置%可以)。<br>一个SQL只能利用到复合索引中的一列进行范围查询。<br>使用left join或not exists来优化not in操作（not in会使索引失效）。</p><h3 id="4-程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#4-程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="4.程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>4.程序连接不同的数据库使用不同的账号，禁止跨库查询</h3><p>为数据库迁移和分库分表留出余地。降低业务耦合度。避免由于权限过大而产生安全风险。</p><h3 id="5-避免使用子查询，可以把子查询优化为join操作"><a href="#5-避免使用子查询，可以把子查询优化为join操作" class="headerlink" title="5.避免使用子查询，可以把子查询优化为join操作"></a>5.避免使用子查询，可以把子查询优化为join操作</h3><p>子查询的结果集无法使用索引。子查询会产生临时表操作，如果子查询数据量大则严重影响效率。消耗过多的CPU及IO资源。</p><h3 id="6-禁止使用order-by-rand-进行随机排序"><a href="#6-禁止使用order-by-rand-进行随机排序" class="headerlink" title="6.禁止使用order by rand()进行随机排序"></a>6.禁止使用order by rand()进行随机排序</h3><p>会把表中所有符合条件的数据装载到内存中进行排序。会消耗大量的CPU和IO及内存资源。推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h3 id="7-where从句中禁止对列进行函数转换和计算"><a href="#7-where从句中禁止对列进行函数转换和计算" class="headerlink" title="7.where从句中禁止对列进行函数转换和计算"></a>7.where从句中禁止对列进行函数转换和计算</h3><p>对列进行函数转换或计算会导致无法使用索引。例如where date(createtime) = ‘20180108’,应使用where createtime &gt;= ‘20180108’ and createtime &lt; ‘20180109’</p><h3 id="8-在明显不会有重复值时使用union-all-而不是union"><a href="#8-在明显不会有重复值时使用union-all-而不是union" class="headerlink" title="8.在明显不会有重复值时使用union all 而不是union"></a>8.在明显不会有重复值时使用union all 而不是union</h3><p>union会把所有数据放在临时表中后再进行去重操作<br>union all不会再对结果集进行去重操作</p><h3 id="9-拆分复杂的大Sql为多个小Sql"><a href="#9-拆分复杂的大Sql为多个小Sql" class="headerlink" title="9.拆分复杂的大Sql为多个小Sql"></a>9.拆分复杂的大Sql为多个小Sql</h3><p>Mysql一个sql只能使用一个CPU进行计算<br>Sql拆分后可以通过并行执行来提高处理效率</p><h2 id="6-数据库操作行为规范"><a href="#6-数据库操作行为规范" class="headerlink" title="6.数据库操作行为规范"></a>6.数据库操作行为规范</h2><h3 id="1-超100万行的批量写操作，要分多批次进行操作"><a href="#1-超100万行的批量写操作，要分多批次进行操作" class="headerlink" title="1.超100万行的批量写操作，要分多批次进行操作"></a>1.超100万行的批量写操作，要分多批次进行操作</h3><p>大批量操作可能会造成严重的主从延迟。binlog日志为row格式时会产生大量的日志。避免产生大事务操作。</p><h3 id="2-对于大表使用pt-online-schema-change修改表结构"><a href="#2-对于大表使用pt-online-schema-change修改表结构" class="headerlink" title="2.对于大表使用pt-online-schema-change修改表结构"></a>2.对于大表使用pt-online-schema-change修改表结构</h3><p>避免大表修改产生的主从延迟。避免在对表字段进行修改时进行锁表。</p><h3 id="3-禁止为程序员使用的账号赋予super权限"><a href="#3-禁止为程序员使用的账号赋予super权限" class="headerlink" title="3.禁止为程序员使用的账号赋予super权限"></a>3.禁止为程序员使用的账号赋予super权限</h3><p>当达到最大连接数限制时，还允许1个有super权限的用户连接。super权限只能留给DBA处理账号使用。</p><h3 id="4-对于程序连接数据库账号，遵循权限最小原则"><a href="#4-对于程序连接数据库账号，遵循权限最小原则" class="headerlink" title="4.对于程序连接数据库账号，遵循权限最小原则"></a>4.对于程序连接数据库账号，遵循权限最小原则</h3><p>程序使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql数据库设计规范&quot;&gt;&lt;a href=&quot;#Mysql数据库设计规范&quot; class=&quot;headerlink&quot; title=&quot;Mysql数据库设计规范&quot;&gt;&lt;/a&gt;Mysql数据库设计规范&lt;/h1&gt;&lt;p&gt;1、数据库命名规范&lt;br&gt;2、数据库基本设计规范&lt;br&gt;3、数据库索引设计规范&lt;br&gt;4、数据库字段设计规范&lt;br&gt;5、数据库SQL开发规范&lt;br&gt;6、数据库操作行为规范（针对运维）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="Mysql设计规范" scheme="http://yoursite.com/tags/Mysql%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 61. Rotate List</title>
    <link href="http://yoursite.com/2018/01/03/LeetCode-61-Rotate-List/"/>
    <id>http://yoursite.com/2018/01/03/LeetCode-61-Rotate-List/</id>
    <published>2018-01-03T14:24:08.000Z</published>
    <updated>2018-01-03T16:05:41.927Z</updated>
    
    <content type="html"><![CDATA[<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p><p>Example:</p><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,</p><p>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode rotateRight(ListNode head, int k) &#123;</span><br><span class="line">        if (head == null || head.next == null || k == 0) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode h = head;</span><br><span class="line">        int len = 1;</span><br><span class="line">//求链表长度</span><br><span class="line">        while (h.next != null) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">//改成单向循环链表</span><br><span class="line">        h.next = head;</span><br><span class="line">//找到要被置为空节点</span><br><span class="line">        for (int i = 0; i &lt; len - k % len; i++) &#123;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode t = h.next;</span><br><span class="line">        h.next = null;</span><br><span class="line">        return t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Given a list, rotate the list to the right by k places, where k is non-negative.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL and k = 2,&lt;/p&gt;
&lt;p&gt;return 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 60. Permutation Sequence</title>
    <link href="http://yoursite.com/2018/01/03/LeetCode-60-Permutation-Sequence/"/>
    <id>http://yoursite.com/2018/01/03/LeetCode-60-Permutation-Sequence/</id>
    <published>2018-01-03T13:41:42.000Z</published>
    <updated>2018-01-03T13:47:12.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h1><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p><p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p><p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.<br><a id="more"></a><br>首先看给出的样例的解题思路：<br>最高位可以取{1, 2, 3, 4}，而每个数重复3! = 6次。所以第k=9个permutation的s[0]为{1, 2, 3, 4}中的第9/6+1 = 2个数字s[0] = 2。</p><p>而对于以2开头的6个数字而言，k = 9是其中的第k’ = 9%(3!) = 3个。而剩下的数字{1, 3, 4}的重复周期为2! = 2次。所以s[1]为{1, 3, 4}中的第k’/(2!)+1 = 2个，即s[1] = 3。</p><p>对于以23开头的2个数字而言，k = 9是其中的第k’’ = k’%(2!) = 1个。剩下的数字{1, 4}的重复周期为1! = 1次。所以s[2] = 1.</p><p>对于以231开头的一个数字而言，k = 9是其中的第k’’’ = k’’/(1!)+1 = 1个。s[3] = 4<br>需要注意就是代码中k–和数组下标从0开始对应，mod = mod / (n - i),每定一个数的位置就会排列的种类就会减少这么多，用全排列数学思想去理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String getPermutation(int n, int k) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        int mod =  1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            mod = mod * i;</span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            mod = mod / (n - i);</span><br><span class="line">            int curIndex = k / mod;</span><br><span class="line">            k = k % mod;</span><br><span class="line">            res += list.get(curIndex);</span><br><span class="line">            list.remove(curIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;60-Permutation-Sequence&quot;&gt;&lt;a href=&quot;#60-Permutation-Sequence&quot; class=&quot;headerlink&quot; title=&quot;60. Permutation Sequence&quot;&gt;&lt;/a&gt;60. Permutation Sequence&lt;/h1&gt;&lt;p&gt;The set [1,2,3,…,n] contains a total of n! unique permutations.&lt;/p&gt;
&lt;p&gt;By listing and labeling all of the permutations in order,&lt;br&gt;We get the following sequence (ie, for n = 3):&lt;/p&gt;
&lt;p&gt;“123”&lt;br&gt;“132”&lt;br&gt;“213”&lt;br&gt;“231”&lt;br&gt;“312”&lt;br&gt;“321”&lt;br&gt;Given n and k, return the kth permutation sequence.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 59. Spiral Matrix II</title>
    <link href="http://yoursite.com/2018/01/03/LeetCode-59-Spiral-Matrix-II/"/>
    <id>http://yoursite.com/2018/01/03/LeetCode-59-Spiral-Matrix-II/</id>
    <published>2018-01-03T13:34:31.000Z</published>
    <updated>2018-01-03T13:42:26.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h1><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p><p>For example,<br>Given n = 3,</p><p>You should return the following matrix:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][] a = new int[n][n];</span><br><span class="line">        int right = n - 1;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom = n - 1;</span><br><span class="line">        int count = 1;</span><br><span class="line">        while (count &lt;= n * n) &#123;</span><br><span class="line">            for (int i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                a[top][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            for (int j = top; j &lt;= bottom; j++) &#123;</span><br><span class="line">                a[j][right] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            for (int i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                a[bottom][i] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            for (int j = bottom; j &gt;= top; j--) &#123;</span><br><span class="line">                a[j][left] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;59-Spiral-Matrix-II&quot;&gt;&lt;a href=&quot;#59-Spiral-Matrix-II&quot; class=&quot;headerlink&quot; title=&quot;59. Spiral Matrix II&quot;&gt;&lt;/a&gt;59. Spiral Matrix II&lt;/h1&gt;&lt;p&gt;Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given n = 3,&lt;/p&gt;
&lt;p&gt;You should return the following matrix:&lt;br&gt;[&lt;br&gt; [ 1, 2, 3 ],&lt;br&gt; [ 8, 9, 4 ],&lt;br&gt; [ 7, 6, 5 ]&lt;br&gt;]&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>细说Java两大关键字volatile和synchronized</title>
    <link href="http://yoursite.com/2017/12/31/%E7%BB%86%E8%AF%B4Java%E4%B8%A4%E5%A4%A7%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronized/"/>
    <id>http://yoursite.com/2017/12/31/细说Java两大关键字volatile和synchronized/</id>
    <published>2017-12-31T15:54:03.000Z</published>
    <updated>2018-01-07T13:07:38.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、volatile关键字"><a href="#1、volatile关键字" class="headerlink" title="1、volatile关键字"></a>1、volatile关键字</h1><h2 id="1-1-volatile关键字具备可见性和有序性。"><a href="#1-1-volatile关键字具备可见性和有序性。" class="headerlink" title="1.1 volatile关键字具备可见性和有序性。"></a>1.1 volatile关键字具备可见性和有序性。</h2><p>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。由此又引出了一个概念。共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。下文会有详细例子讲解。<br><img src="/2017/12/31/细说Java两大关键字volatile和synchronized/Java内存模型.png" alt="Java内存模型"> <a id="more"></a><br>如上图所示，表示Java内存模型。我们看到，(1)线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。(2)不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<br>共享变量可见性实现的原理：线程1对共享变量的修改要想被线程2及时看到，必须要经过下面两个步骤。(1)把工作内存1中更新过的共享变量刷新到主内存中。(2)将主内存中最新的共享变量的值更新到工作内存2中。<br><img src="/2017/12/31/细说Java两大关键字volatile和synchronized/共享变量可见性实现原理.png" alt="共享变量可见性实现原理"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class RunThread extends Thread&#123;</span><br><span class="line"></span><br><span class="line">//此处先不使用volatile</span><br><span class="line">private  boolean isRunning = true;</span><br><span class="line">private void setRunning(boolean isRunning)&#123;</span><br><span class="line">this.isRunning = isRunning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()&#123;</span><br><span class="line">System.out.println(&quot;进入run方法..&quot;);</span><br><span class="line">while(isRunning == true)&#123;</span><br><span class="line">//..</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;线程停止&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">RunThread rt = new RunThread();</span><br><span class="line">rt.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(5);</span><br><span class="line">rt.setRunning(false);</span><br><span class="line">System.out.println(&quot;isRunning的值已经被设置了false&quot;);</span><br><span class="line">System.out.println(rt.isRunning);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示代码，很有可能isRunning被设为false了，但是rt线程没有停下来。因为是主线程中去对isRunning做设置的，rt线程工作内存中的副本很有可能还是isRunning还是true。所以需要加volatile关键字保证主线程对isRunning的设置的值让rt线程可见。<br>volatile的汇编代码中会多了Lock前缀指令，Lock指令在多核处理器会引发下面两件事情.<br>(1)将当前处理器缓存行的数据写会到系统内存。<br>(2)这个写会内存的操作会使在其他CPU中缓存了该内存地址的数据无效。<br>我用我自己理解来讲下里面的细节，Lock对于不同的处理器架构会有些差别，Lock指令之前是采取锁总线的策略，由于系统开销和效率原因，改成锁缓存的策略；缓存一致性协议，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是否过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置成无效状态，当处理前对对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>有序性：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。<br>(1)编译器优化的重排序（编译器优化）<br>(2)指令级并行重排序  （处理器优化）<br>(3)内存系统的重排序  （处理器优化）<br>但是重排序又是遵循一定的规则，编译器和处理器做了让步，为了给程序员提供一定保证，有些我不优化，但是为了效率有些我是要优化，这种折中的思想在计算机领域随处可见，比如Unix操作系统为何用少量的汇编和c语言混写呢，为了提高效率的同时保证系统的可读性。于是，有happen-before。（编译器或处理器和程序员签了一个平等条约，happen-before条约）volatile关键有序性实现是通过插入内存屏障来实现的，内存屏障前和内存屏障后的代码是不能重排序的。<br>happen-before原则：<br>1、as-if-serial语义：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致。<br>2、管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。<br>3、volatile变量规则：对一个volatile变量的写操作先行于后面对这个变量的读操作。<br>4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。<br>5、线程终止规则：线程中所有操作都先行发生于对此线程的终止检测。<br>6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。<br>7、对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。<br>8、传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。</p><h2 id="1-2-单例模式，很多文章中有错误。"><a href="#1-2-单例模式，很多文章中有错误。" class="headerlink" title="1.2 单例模式，很多文章中有错误。"></a>1.2 单例模式，很多文章中有错误。</h2><p>单例模式大家都熟知，很多文章用DoubleCheckLocking去实现时，没有给instance加上volatile关键字，这就有问题了。创建对象是可以分为以下三步：<br>memory = allocate(); //1、为对象分配内存空间<br>instance = memory;   //2、初始化对象<br>instance = memory;  //3、设置instance指向刚分配的内存地址<br>你能保证这三步是顺序执行的吗？可能是线程A进入了同步代码块，先执行1，再执行3，此时线程B判断instance不为空，就会去用instance，而此时instance还未完成初始化，这就一个不安全的引用发布。然后执行所以需要加上volatile关键，volatile关键字在happen-before规则中的定义是对一个volatile变量的写操作先行于后面对这个变量的读操作。线程A对instance写是先行发生于线程B的读。不会出现上述问题。当然，你也可以用静态内部类来写单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static Instance getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">synchronized (DoubleCheckLocking.class) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance == new Instance();//问题根源</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-3-请记住volatile不具备原子性。"><a href="#1-3-请记住volatile不具备原子性。" class="headerlink" title="1.3 请记住volatile不具备原子性。"></a>1.3 请记住volatile不具备原子性。</h2><p>下面用10个线程，每个线程对count做1000次加法，结果并不等于10000。<br>concurrent包下有提供原子操作类供使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * volatile关键字不具备synchronized关键字的原子性（同步）</span><br><span class="line"> * @author chenjun</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class VolatileNoAtomic extends Thread&#123;</span><br><span class="line">private static volatile int count;</span><br><span class="line">private static void addCount()&#123;</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run()&#123;</span><br><span class="line">addCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">VolatileNoAtomic[] arr = new VolatileNoAtomic[100];</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">arr[i] = new VolatileNoAtomic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">arr[i].start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2、synchronized"><a href="#2、synchronized" class="headerlink" title="2、synchronized"></a>2、synchronized</h1><h2 id="2-1-synchronized的可见性"><a href="#2-1-synchronized的可见性" class="headerlink" title="2.1 synchronized的可见性"></a>2.1 synchronized的可见性</h2><p>synchronized具有可见性和原子性。这很常见的，大家都知道。我就说下synchronized的可见性，可能有些人忘了.<br>(1)线程解锁前，必须把共享变量的最新值刷新到主内存中。<br>(2)线程加锁时，将清空工作内存中共享变量值，从而使用共享变量时需要从主内存中重新读取最新的值。</p><h2 id="2-2-synchronized的几个注意事项"><a href="#2-2-synchronized的几个注意事项" class="headerlink" title="2.2 synchronized的几个注意事项"></a>2.2 synchronized的几个注意事项</h2><p>1、一定是同一把锁<br>2、它是可重入锁，代码如下.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized的重入</span><br><span class="line"> * @author chenjun</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class SyncDubbo1 &#123;</span><br><span class="line"></span><br><span class="line">public synchronized void method1()&#123;</span><br><span class="line">System.out.println(&quot;method1..&quot;);</span><br><span class="line">method2();</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void method2()&#123;</span><br><span class="line">System.out.println(&quot;method2..&quot;);</span><br><span class="line">method3();</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void method3()&#123;</span><br><span class="line">System.out.println(&quot;method3..&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final SyncDubbo1 sd = new SyncDubbo1();</span><br><span class="line">Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">sd.method1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3、不要使用字符串常量作为锁对象。"><a href="#3、不要使用字符串常量作为锁对象。" class="headerlink" title="3、不要使用字符串常量作为锁对象。"></a>3、不要使用字符串常量作为锁对象。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * synchronized代码块对字符串的锁，注意String常量池的缓存功能</span><br><span class="line"> * @author chenjun</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StringLock &#123;</span><br><span class="line"></span><br><span class="line">public void method() &#123;</span><br><span class="line">//new String(&quot;字符串常量&quot;)</span><br><span class="line">synchronized (&quot;字符串常量&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot;开始&quot;);</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">System.out.println(&quot;当前线程 : &quot;  + Thread.currentThread().getName() + &quot;结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final StringLock stringLock = new StringLock();</span><br><span class="line">Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">stringLock.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,&quot;t1&quot;);</span><br><span class="line">Thread t2 = new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">stringLock.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁效果图如下：<br><img src="/2017/12/31/细说Java两大关键字volatile和synchronized/字符串常量作为锁对象.png" alt="字符串常量作为锁对象.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、volatile关键字&quot;&gt;&lt;a href=&quot;#1、volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;1、volatile关键字&quot;&gt;&lt;/a&gt;1、volatile关键字&lt;/h1&gt;&lt;h2 id=&quot;1-1-volatile关键字具备可见性和有序性。&quot;&gt;&lt;a href=&quot;#1-1-volatile关键字具备可见性和有序性。&quot; class=&quot;headerlink&quot; title=&quot;1.1 volatile关键字具备可见性和有序性。&quot;&gt;&lt;/a&gt;1.1 volatile关键字具备可见性和有序性。&lt;/h2&gt;&lt;p&gt;可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。由此又引出了一个概念。共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。下文会有详细例子讲解。&lt;br&gt;&lt;img src=&quot;/2017/12/31/细说Java两大关键字volatile和synchronized/Java内存模型.png&quot; alt=&quot;Java内存模型&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何从Java小白到收割大厂offer</title>
    <link href="http://yoursite.com/2017/12/30/%E5%A6%82%E4%BD%95%E4%BB%8EJava%E5%B0%8F%E7%99%BD%E5%88%B0%E6%94%B6%E5%89%B2%E5%A4%A7%E5%8E%82offer/"/>
    <id>http://yoursite.com/2017/12/30/如何从Java小白到收割大厂offer/</id>
    <published>2017-12-30T08:05:20.000Z</published>
    <updated>2018-01-07T13:08:08.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="收割大厂offer需要具备的条件"><a href="#收割大厂offer需要具备的条件" class="headerlink" title="收割大厂offer需要具备的条件"></a>收割大厂offer需要具备的条件</h1><p>本人也一直在关注互联网，觉得还是有些了解。互联网要求是越来越高了，竞争的人太多了，不过你不用担心，个人觉得，你到了中层的水平，拿二线offer应该问题，人多也有人多的好处，我比别人多努力一点，我就超过了很多人了，个人觉得需要具备以下条件，如图所示：<br><img src="/2017/12/30/如何从Java小白到收割大厂offer/大厂offer收割.png" alt="大厂要求"><br><a id="more"></a></p><h2 id="1、Java语言基础"><a href="#1、Java语言基础" class="headerlink" title="1、Java语言基础"></a>1、Java语言基础</h2><h3 id="1-1-刷基础题库，读JDK源码"><a href="#1-1-刷基础题库，读JDK源码" class="headerlink" title="1.1 刷基础题库，读JDK源码"></a>1.1 刷基础题库，读JDK源码</h3><p>首先你就能想到String就有很多坑，比如String s = new String(“abc”);这里会产生几个字符串呢。两个首先会去常量池中查找有没有字符串abc,首次肯定是没有的，然后会去常量池放一个abc做缓存，然后再去堆上创建一个字符串abc,然后把引用给s。我对坑的理解是要去读源码和了解底层原理，高级语言就是这样的，很多事都帮你做好了，也叫作语法糖吧！写着用着很方便，但是不利于理解和成长。对于这块的建议，真正的小白，看传智的视频，1.5倍播速，自己跟着敲，代码一定要多敲，敲多了或许你感觉自然不一样了。然后去牛客对着Java基础题库来刷。这样过一遍应该已经很扎实了，然后去看JDK的源码。</p><h3 id="1-2-读JVM，并发编程"><a href="#1-2-读JVM，并发编程" class="headerlink" title="1.2 读JVM，并发编程"></a>1.2 读JVM，并发编程</h3><p>基础当然不仅仅指语言基础了，concurrent包下的面试官也很喜欢问，估计能用的好也不多，基于实现原理都是采用CAS+volatile，比如CountDownLatch，CyclicBarrier让你模拟五个运动员跑步场景，包括提供各种有界，无界阻塞队列都有他自己应用场景。JVM就不用说了，这是必问的，我想除了理论知识很扎实之外，自己最好动手玩玩，比如用Jmeter去做压力测试，自己设置JVM堆大小，栈大小，使用不同的垃圾收集器做对比，这样自己应该体会更深的，我们码农啊！一定要理论+实践双管齐下。书籍很常见的是就是《深入理解Java虚拟机》、《Java并发编程艺术》和《Java并发编程实战》（此书我还需要看第二遍）。</p><h2 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h2><p>我自己是计划LeetCode刷300题刷两遍，应该很稳了。我想这是大厂的基本条件吧！别扯那些没用的，工作中这些用不到什么的。对于一个应届生来说，你项目经验缺乏，代码能力不够，我为何招你进来的，大厂对应届上看重更是可塑性，那我为何招你不招别人，就是对计算机基础知识的比拼，可塑性体现在哪呢。算法牛逼，至少说明你逻辑思维牛逼，分析能力强等。比如LeetCode有到merge K list，它的原型不就是常见的大文件，但是服务器内存有限，让你如何来设计排序。写算法时候尽量不要用编译器，比如idea，eclipse等快捷键用着太爽了，爱不释手，但是面试时候，基本都是手写无编译器给你爽了，要做刻意的适应，前两周参加头条的实习生招聘，六道算法题，就发了四张A4纸给你，平时用习惯了的筒子们，估计会难受的。我觉得好好刷LeetCode就够了。</p><h2 id="3、数据库"><a href="#3、数据库" class="headerlink" title="3、数据库"></a>3、数据库</h2><p>作为Java后台研发工程师，他们对数据库要求还是很高的，建议看《高性能Mysql》和《数据库存储引擎内幕》。比如Mysql底层索引原理，事务隔离级别，对应着解决脏读，不可重复读，幻读（虚读），看到这时候你不是应该拿数据库做实验，理论和实战结合会让你理解更加深刻。比如行锁采用的Record Lock， Gap Lock，Record Lock + Gap Lock = Next-key Lock。Mysql分布式事务采用的两阶段提交协议，这种协议高并发情况下，不行，一般采用消息队列。</p><h2 id="4、操作系统和网络"><a href="#4、操作系统和网络" class="headerlink" title="4、操作系统和网络"></a>4、操作系统和网络</h2><p>这一块看面试官吧，可能有些很喜欢问，有些不怎么问！我个人是在看《Unix操作系统设计》一书，讲的操作系统内核，已经算比较深入了。最基本操作系统一些原理要清楚，就怕问到了，比如页式存储管理，段页式存储管理，给你个逻辑地址你要会算的出来物理地址吧！再就是我们对Unix基本操作肯定要会的，可能会问怎么找到java进程（ps -ef | grep java）等等，你直接去搜每天一个Linux命令，每天玩一个，应该问题不大了。网络看谢希仁《计算机网络》或者自顶向下计算机网络，我打算看的是TCP/IP详解。至少你知道TCP/IP数据报文格式，三次握手和四次挥手，能画的出来，包括每个阶段是什么状态，滑动窗口协议，拥塞控制机制。因为精力的确有限啊，连着每天2点多睡了，有点虚了。</p><h2 id="5、高并发，系统设计题"><a href="#5、高并发，系统设计题" class="headerlink" title="5、高并发，系统设计题"></a>5、高并发，系统设计题</h2><p>这对于应届生的确很难，我觉得至少我们要做对这些概念都清楚，理论方案都熟悉，应该就可以了。比如常用的Nginx负载均衡，反向代理，Redis做缓存，用lua脚本实现它的原子操作，分库，分表，用消息队列限流提高并发能力，常用设计模式要会吧，还有Netty等等！设计模式之禅一书我看了一半实在看不下去了。真的很难理解的，或者说当时知道，过后就忘了。场景题，我个人觉得至少提出两种解决方案，根据不同业务需求说不同方案，比你泛泛而谈要很多，比如秒杀系统超卖的控制，传统公司可能就会用存储过程，互联网公司可能会用乐观锁+时间戳来实现，适用于读多写少的场景，当乐观锁失败太多了，那就改为悲观锁吧！用for update的X锁。</p><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>感觉啊就是多看书，多搬砖，入门阶段会有很多困难，你会怀疑人生，怀疑自己适不适合代码（我应该是适合放牛吧，别人为何那么厉害），刚开始基本上靠毅力支持，等你坚持做一段时间，发现你更之前进不许多，会有成就感，从此你会爱上搬砖，这是很有可能，我好像也爱上搬砖了。累了，疲了找好朋友聊聊人生，抱怨一下，但是第二天依旧要搬砖，告诉自己，稳住，我们能赢！多想多对比，这些理论知识最终为了我们实践服务的。<br>作为支持附上传智17年的视频：链接：<a href="https://pan.baidu.com/s/1cnXpHc" target="_blank" rel="noopener">https://pan.baidu.com/s/1cnXpHc</a> 密码：skau<br>很多视频自己可以去闲鱼买的，都很便宜的。划算的。<br><img src="/2017/12/30/如何从Java小白到收割大厂offer/1.jpg" alt="好好搬砖"></p><p>本人研一学生，如有理解错误之处，请多多包涵，欢迎下面留言指出，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;收割大厂offer需要具备的条件&quot;&gt;&lt;a href=&quot;#收割大厂offer需要具备的条件&quot; class=&quot;headerlink&quot; title=&quot;收割大厂offer需要具备的条件&quot;&gt;&lt;/a&gt;收割大厂offer需要具备的条件&lt;/h1&gt;&lt;p&gt;本人也一直在关注互联网，觉得还是有些了解。互联网要求是越来越高了，竞争的人太多了，不过你不用担心，个人觉得，你到了中层的水平，拿二线offer应该问题，人多也有人多的好处，我比别人多努力一点，我就超过了很多人了，个人觉得需要具备以下条件，如图所示：&lt;br&gt;&lt;img src=&quot;/2017/12/30/如何从Java小白到收割大厂offer/大厂offer收割.png&quot; alt=&quot;大厂要求&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="offer" scheme="http://yoursite.com/tags/offer/"/>
    
  </entry>
  
</feed>
